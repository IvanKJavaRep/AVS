1. Создаем файл Array.c
2. gcc -S -O0 Array.c
Будет создан ассемблерный файл Array.s, откомпилированный без оптимизирующих и отладочных опций 
из-за использования ключа -O0

Добавить комментарии в файл Array.s. Скопируем содержимое этого файла, создадим файл descripcionLongAssembly.txt
и в нем уже будем добавлять комментарии к коду.

3. gcc -S -O0 -Wall -masm=intel -fno-asynchronous-unwind-tables -fcf-protection=none Array.c -o Array_final.s
данная команда уберет все макросы .cfi, которые генерируют отладочную информацию.
cat Array_final.s | awk '/^\t\./ { print $1 }' | sort | uniq > asm_macros.md
Данная команда создаст файл asm_macros.md на основе Array_final.s, в котором 
будут записаны все используемые макросы. Если выполним то же самое для  файла Array.c, то там будут 
макросы .cfi

4. gcc -O0 Array_final.s -o Array_final.out 
данная команда создаст исполняемый файл Array_final.out из ассемблерного файла Array_final.s
5. gcc -O0 Array.s -o Array.out 
данная команда создаст исполняемый файл Array.out из ассемблерного файла Array.s
6. Чтобы запустить файл и протестировать, нужно переместиться в папку с файлом и выполнить команду
./Array.out или ./Array_final.out. Выполним обе команды, чтобы сравнить результаты тестов.

тесты:
1) n = 0 
Результат:
"для выполнения задачи массив должн состоять минимум из дву элементов,
а для исключения использования слишком большого количества ресурсов,
ограничим сверху числом 1000"
2) n = 1000
Результат:
"для выполнения задачи массив должн состоять минимум из дву элементов,
а для исключения использования слишком большого количества ресурсов,
ограничим сверху числом 1000"
3) n = 2 a[] = {1,7} 
Результат: массив b сформирован, результат вывода его элементов в консоль: 8
4) n = 5 a[] = {1,2,3,4,-10}
Результат: массив b сформирован, результат вывода его элементов в консоль: 3 5 7 -6

Вывод: обе программы дают одинаковый и корректный результат на тестах.

7. отчет