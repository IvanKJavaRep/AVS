
4 БАЛЛА

1. Создаем файл Array.c 
2. gcc -S -O0 Array.c
Будет создан ассемблерный файл Array.s, откомпилированный без оптимизирующих и отладочных опций 
из-за использования ключа -O0

Добавить комментарии в файл Array.s. Скопируем содержимое этого файла, создадим файл descripcionLongAssembly.s
и в нем уже будем добавлять комментарии к коду.

3. gcc -S -O0 -Wall -masm=intel -fno-asynchronous-unwind-tables -fcf-protection=none Array.c -o Array_final.s
данная команда уберет все макросы .cfi, которые генерируют отладочную информацию.


cat Array_final.s | awk '/^\t\./ { print $1 }' | sort | uniq > asm_macros.md
Данная команда создаст файл asm_macros.md на основе Array_final.s, в котором 
будут записаны все используемые макросы. Если выполним то же самое для  файла Array.c, то там будут 
макросы .cfi

4. gcc -O0 Array_final.s -o Array_final.out 
данная команда создаст исполняемый файл Array_final.out из ассемблерного файла Array_final.s
5. gcc -O0 Array.s -o Array.out 
данная команда создаст исполняемый файл Array.out из ассемблерного файла Array.s


6. Чтобы запустить файл и протестировать, нужно переместиться в папку с файлом и выполнить команду
./Array.out или ./Array_final.out. Выполним обе команды, чтобы сравнить результаты тестов.

тесты:
1) файл test3.txt n = 0  
Результат:
"для выполнения задачи массив должн состоять минимум из дву элементов,
а для исключения использования слишком большого количества ресурсов,
ограничим сверху числом 1000"
2) файл test4.txt n = 1000
Результат:
"для выполнения задачи массив должн состоять минимум из дву элементов,
а для исключения использования слишком большого количества ресурсов,
ограничим сверху числом 1000"
3) файл test2.txt n = 2 a[] = {1,7} 
Результат: массив b сформирован, результат вывода его элементов в консоль: 8
4) файл test1.txt n = 5 a[] = {1,2,3,4,-10}
Результат: массив b сформирован, результат вывода его элементов в консоль: 3 5 7 -6

Вывод: обе программы дают одинаковый и корректный результат на тестах. 
Результаты всех программ на тестах 1-4 приведены на скриншоте (файл all_tests.png), включая программы на 5 и 6 баллов.
Все проведенные модификации сохраняют корректность работы программы.




5 БАЛЛОВ

1. Создадим файл Array_with_parameters.c, в который добавим функцию sum_pairs(int n, int a[], int b[]).
Также, внутри этой функции будет локальная переменная i, чтобы показать, как ассемблер сохраняет ее на стеке.

2. С помощью команды из пункта 3 первой секции, но без ключа -masm=intel, 
так как файл Array.s был не в стиле интел создадим файл Array_with_parameters.s и Array_with_parameters_edited.s

3. В файле Array_with_parameters_edited.s есть все необходимые комментарии, которые описывают передачу фактических параметров
через регистры и перенос возвращаемого результата, а также связь между формальными параметрами и регистрами.



6 БАЛЛОВ

1. В тот же файл Array_with_parameters_edited.s и будем вносить изменения, так как никакого рефакторинга до этого не было (на 5 баллов только комментарии).

2. Сделан рефакторинг программы засчет замещения обращения к стеку, с помощью сохранения нужных значений в регистры процессора, которые 
изменяются только пользователем и не могут быть очищены автоматически.

3. В файле оставлено два куска кода до/после. Второй кусок выполняет то же самое, что и первый. Каждый из них может быть заменен другим.
Оставлен для наглядности.

4. Некоторые обращения к стеку в функции мэйн мы должны оставить, так как функция scanf должна обязательно записывать в память. А потом мы можем
сложить значение из памяти в регистр самостоятельно. Также нельзя положить весь массив в регистры, потому что их ограниченное количество, то есть 
единственный вариант - брать значения из памяти по адресу.

5. также создан файл Array_with_parameters_edited.out, который показывает корректную работу программы после внесения всех изменений на тестах 1-2.
Для упрощения кода были убраны ограничения на длину исходного массива и проходят тесты только на массивах длины 5 и 2. На них программа отрабатывает верно.
Остальные случаи не уместны в контексте этой задачи. Я показал работу с регистрами, вместо стека, а построение программы, которая отрабатывала
красиво на всех входных данных усложнило бы ассемблер и наглядность использование собственных регитсров сильно упала.
